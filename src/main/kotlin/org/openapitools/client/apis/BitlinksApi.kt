/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import com.squareup.moshi.Json
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue
import org.openapitools.client.models.BitlinkBody
import org.openapitools.client.models.Bitlinks
import org.openapitools.client.models.BulkUpdate
import org.openapitools.client.models.BulkUpdateRequest
import org.openapitools.client.models.CityMetrics
import org.openapitools.client.models.ClickMetrics
import org.openapitools.client.models.Clicks
import org.openapitools.client.models.ClicksSummary
import org.openapitools.client.models.DeviceMetrics
import org.openapitools.client.models.ExpandBitlink
import org.openapitools.client.models.ExpandedBitlink
import org.openapitools.client.models.FullQRCode
import org.openapitools.client.models.FullShorten
import org.openapitools.client.models.LinkDeletionResponse
import org.openapitools.client.models.QRCustomizations
import org.openapitools.client.models.ReferrersByDomains
import org.openapitools.client.models.Shorten
import org.openapitools.client.models.ShortenBitlinkBody
import org.openapitools.client.models.SortedLinks
import org.openapitools.client.models.TimeUnit
import java.io.IOException

class BitlinksApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api-ssl.bitly.com/v4")
        }
    }

    /**
     * Shorten a Link
     * Converts a long url to a Bitlink. You may see errors returned from this endpoint - \&quot;BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\&quot; occurs if you have shortened more links than your account is configured for for the month, and \&quot;DNS_CONFIGURATION_ERROR\&quot; occurs if you are attempting to shorten links against a custom domain which doesn&#39;t have DNS properly configured.
     * @param shorten
     * @return ShortenBitlinkBody
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBitlink(shorten: Shorten): ShortenBitlinkBody {
        val localVarResponse = createBitlinkWithHttpInfo(shorten = shorten)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ShortenBitlinkBody
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Shorten a Link
     * Converts a long url to a Bitlink. You may see errors returned from this endpoint - \&quot;BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\&quot; occurs if you have shortened more links than your account is configured for for the month, and \&quot;DNS_CONFIGURATION_ERROR\&quot; occurs if you are attempting to shorten links against a custom domain which doesn&#39;t have DNS properly configured.
     * @param shorten
     * @return ApiResponse<ShortenBitlinkBody?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBitlinkWithHttpInfo(shorten: Shorten): ApiResponse<ShortenBitlinkBody?> {
        val localVariableConfig = createBitlinkRequestConfig(shorten = shorten)

        return request<Shorten, ShortenBitlinkBody>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBitlink
     *
     * @param shorten
     * @return RequestConfig
     */
    fun createBitlinkRequestConfig(shorten: Shorten): RequestConfig<Shorten> {
        val localVariableBody = shorten
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/shorten",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a QR Code
     * Creates a QR code for existing Bitlink
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return FullQRCode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBitlinkQRCode(bitlink: kotlin.String, qrCustomizations: QRCustomizations): FullQRCode {
        val localVarResponse = createBitlinkQRCodeWithHttpInfo(bitlink = bitlink, qrCustomizations = qrCustomizations)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FullQRCode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a QR Code
     * Creates a QR code for existing Bitlink
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return ApiResponse<FullQRCode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBitlinkQRCodeWithHttpInfo(bitlink: kotlin.String, qrCustomizations: QRCustomizations): ApiResponse<FullQRCode?> {
        val localVariableConfig = createBitlinkQRCodeRequestConfig(bitlink = bitlink, qrCustomizations = qrCustomizations)

        return request<QRCustomizations, FullQRCode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBitlinkQRCode
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return RequestConfig
     */
    fun createBitlinkQRCodeRequestConfig(bitlink: kotlin.String, qrCustomizations: QRCustomizations): RequestConfig<QRCustomizations> {
        val localVariableBody = qrCustomizations
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/bitlinks/{bitlink}/qr".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a Bitlink
     * Converts a long url to a Bitlink and sets additional parameters. You may see errors returned from this endpoint - \&quot;BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\&quot; occurs if you have shortened more links than your account is configured for for the month, and \&quot;DNS_CONFIGURATION_ERROR\&quot; occurs if you are attempting to shorten links against a custom domain which doesn&#39;t have DNS properly configured.
     * @param fullShorten
     * @return BitlinkBody
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createFullBitlink(fullShorten: FullShorten): BitlinkBody {
        val localVarResponse = createFullBitlinkWithHttpInfo(fullShorten = fullShorten)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BitlinkBody
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a Bitlink
     * Converts a long url to a Bitlink and sets additional parameters. You may see errors returned from this endpoint - \&quot;BRANDED_LINK_MONTHLY_LIMIT_EXCEEDED\&quot; occurs if you have shortened more links than your account is configured for for the month, and \&quot;DNS_CONFIGURATION_ERROR\&quot; occurs if you are attempting to shorten links against a custom domain which doesn&#39;t have DNS properly configured.
     * @param fullShorten
     * @return ApiResponse<BitlinkBody?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createFullBitlinkWithHttpInfo(fullShorten: FullShorten): ApiResponse<BitlinkBody?> {
        val localVariableConfig = createFullBitlinkRequestConfig(fullShorten = fullShorten)

        return request<FullShorten, BitlinkBody>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createFullBitlink
     *
     * @param fullShorten
     * @return RequestConfig
     */
    fun createFullBitlinkRequestConfig(fullShorten: FullShorten): RequestConfig<FullShorten> {
        val localVariableBody = fullShorten
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/bitlinks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete a Bitlink
     * Delete an unedited hash Bitlink.
     * @param bitlink A Bitlink made of the domain and hash
     * @return LinkDeletionResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBitlink(bitlink: kotlin.String): LinkDeletionResponse {
        val localVarResponse = deleteBitlinkWithHttpInfo(bitlink = bitlink)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LinkDeletionResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a Bitlink
     * Delete an unedited hash Bitlink.
     * @param bitlink A Bitlink made of the domain and hash
     * @return ApiResponse<LinkDeletionResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBitlinkWithHttpInfo(bitlink: kotlin.String): ApiResponse<LinkDeletionResponse?> {
        val localVariableConfig = deleteBitlinkRequestConfig(bitlink = bitlink)

        return request<Unit, LinkDeletionResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBitlink
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @return RequestConfig
     */
    fun deleteBitlinkRequestConfig(bitlink: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/bitlinks/{bitlink}".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Expand a Bitlink
     * Returns the short link and long URL for the specified link.
     * @param expandBitlink
     * @return ExpandedBitlink
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun expandBitlink(expandBitlink: ExpandBitlink): ExpandedBitlink {
        val localVarResponse = expandBitlinkWithHttpInfo(expandBitlink = expandBitlink)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpandedBitlink
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Expand a Bitlink
     * Returns the short link and long URL for the specified link.
     * @param expandBitlink
     * @return ApiResponse<ExpandedBitlink?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun expandBitlinkWithHttpInfo(expandBitlink: ExpandBitlink): ApiResponse<ExpandedBitlink?> {
        val localVariableConfig = expandBitlinkRequestConfig(expandBitlink = expandBitlink)

        return request<ExpandBitlink, ExpandedBitlink>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation expandBitlink
     *
     * @param expandBitlink
     * @return RequestConfig
     */
    fun expandBitlinkRequestConfig(expandBitlink: ExpandBitlink): RequestConfig<ExpandBitlink> {
        val localVariableBody = expandBitlink
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/expand",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Retrieve a Bitlink
     * Returns information for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @return BitlinkBody
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBitlink(bitlink: kotlin.String): BitlinkBody {
        val localVarResponse = getBitlinkWithHttpInfo(bitlink = bitlink)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BitlinkBody
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve a Bitlink
     * Returns information for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @return ApiResponse<BitlinkBody?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBitlinkWithHttpInfo(bitlink: kotlin.String): ApiResponse<BitlinkBody?> {
        val localVariableConfig = getBitlinkRequestConfig(bitlink = bitlink)

        return request<Unit, BitlinkBody>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBitlink
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @return RequestConfig
     */
    fun getBitlinkRequestConfig(bitlink: kotlin.String): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter imageFormat
     */
    enum class ImageFormat_getBitlinkQRCode(val value: kotlin.String) {
        @Json(name = "png") png("png"),
        @Json(name = "svg") svg("svg")
    }

    /**
     * Retrieve a QR Code
     * Retrieves a QR code for a Bitlink.
     * @param bitlink A Bitlink made of the domain and hash
     * @param imageFormat Determines the image format of the returned QR code (optional, default to png)
     * @return FullQRCode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBitlinkQRCode(bitlink: kotlin.String, imageFormat: ImageFormat_getBitlinkQRCode? = ImageFormat_getBitlinkQRCode.png): FullQRCode {
        val localVarResponse = getBitlinkQRCodeWithHttpInfo(bitlink = bitlink, imageFormat = imageFormat)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FullQRCode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve a QR Code
     * Retrieves a QR code for a Bitlink.
     * @param bitlink A Bitlink made of the domain and hash
     * @param imageFormat Determines the image format of the returned QR code (optional, default to png)
     * @return ApiResponse<FullQRCode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBitlinkQRCodeWithHttpInfo(bitlink: kotlin.String, imageFormat: ImageFormat_getBitlinkQRCode?): ApiResponse<FullQRCode?> {
        val localVariableConfig = getBitlinkQRCodeRequestConfig(bitlink = bitlink, imageFormat = imageFormat)

        return request<Unit, FullQRCode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBitlinkQRCode
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param imageFormat Determines the image format of the returned QR code (optional, default to png)
     * @return RequestConfig
     */
    fun getBitlinkQRCodeRequestConfig(bitlink: kotlin.String, imageFormat: ImageFormat_getBitlinkQRCode?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (imageFormat != null) {
                    put("image_format", listOf(imageFormat.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/qr".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter archived
     */
    enum class Archived_getBitlinksByGroup(val value: kotlin.String) {
        @Json(name = "on") on("on"),
        @Json(name = "off") off("off"),
        @Json(name = "both") both("both")
    }

    /**
     * enum for parameter deeplinks
     */
    enum class Deeplinks_getBitlinksByGroup(val value: kotlin.String) {
        @Json(name = "on") on("on"),
        @Json(name = "off") off("off"),
        @Json(name = "both") both("both")
    }

    /**
     * enum for parameter domainDeeplinks
     */
    enum class DomainDeeplinks_getBitlinksByGroup(val value: kotlin.String) {
        @Json(name = "on") on("on"),
        @Json(name = "off") off("off"),
        @Json(name = "both") both("both")
    }

    /**
     * enum for parameter customBitlink
     */
    enum class CustomBitlink_getBitlinksByGroup(val value: kotlin.String) {
        @Json(name = "on") on("on"),
        @Json(name = "off") off("off"),
        @Json(name = "both") both("both")
    }

    /**
     * Retrieve Bitlinks by Group
     * Returns a paginated collection of Bitlinks for a group.
     * @param groupGuid A GUID for a Bitly group
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param page Integer specifying the numbered result at which to start (optional, default to 1)
     * @param keyword Custom keyword to filter on history entries (optional)
     * @param query the value that you would like to search (optional)
     * @param createdBefore Timestamp as an integer unix epoch (optional)
     * @param createdAfter Timestamp as an integer unix epoch (optional)
     * @param modifiedAfter Timestamp as an integer unix epoch (optional)
     * @param archived Whether or not to include archived bitlinks (optional, default to off)
     * @param deeplinks Filter to only Bitlinks that contain deeplinks (optional, default to both)
     * @param domainDeeplinks Filter to only Bitlinks that contain deeplinks configured with a custom domain (optional, default to both)
     * @param campaignGuid Filter to return only links for the given campaign GUID, can be provided (optional)
     * @param channelGuid Filter to return only links for the given channel GUID, can be provided, overrides all other parameters (optional)
     * @param customBitlink  (optional, default to both)
     * @param tags filter by given tags (optional)
     * @param launchpadIds filter by launchpad id (optional)
     * @param encodingLogin Filter by the login of the authenticated user that created the Bitlink (optional)
     * @return Bitlinks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBitlinksByGroup(groupGuid: kotlin.String, size: kotlin.Int? = 50, page: kotlin.Int? = 1, keyword: kotlin.String? = null, query: kotlin.String? = null, createdBefore: kotlin.Int? = null, createdAfter: kotlin.Int? = null, modifiedAfter: kotlin.Int? = null, archived: Archived_getBitlinksByGroup? = Archived_getBitlinksByGroup.off, deeplinks: Deeplinks_getBitlinksByGroup? = Deeplinks_getBitlinksByGroup.both, domainDeeplinks: DomainDeeplinks_getBitlinksByGroup? = DomainDeeplinks_getBitlinksByGroup.both, campaignGuid: kotlin.String? = null, channelGuid: kotlin.String? = null, customBitlink: CustomBitlink_getBitlinksByGroup? = CustomBitlink_getBitlinksByGroup.both, tags: kotlin.collections.List<kotlin.String>? = null, launchpadIds: kotlin.collections.List<kotlin.String>? = null, encodingLogin: kotlin.collections.List<kotlin.String>? = null): Bitlinks {
        val localVarResponse = getBitlinksByGroupWithHttpInfo(groupGuid = groupGuid, size = size, page = page, keyword = keyword, query = query, createdBefore = createdBefore, createdAfter = createdAfter, modifiedAfter = modifiedAfter, archived = archived, deeplinks = deeplinks, domainDeeplinks = domainDeeplinks, campaignGuid = campaignGuid, channelGuid = channelGuid, customBitlink = customBitlink, tags = tags, launchpadIds = launchpadIds, encodingLogin = encodingLogin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Bitlinks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Bitlinks by Group
     * Returns a paginated collection of Bitlinks for a group.
     * @param groupGuid A GUID for a Bitly group
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param page Integer specifying the numbered result at which to start (optional, default to 1)
     * @param keyword Custom keyword to filter on history entries (optional)
     * @param query the value that you would like to search (optional)
     * @param createdBefore Timestamp as an integer unix epoch (optional)
     * @param createdAfter Timestamp as an integer unix epoch (optional)
     * @param modifiedAfter Timestamp as an integer unix epoch (optional)
     * @param archived Whether or not to include archived bitlinks (optional, default to off)
     * @param deeplinks Filter to only Bitlinks that contain deeplinks (optional, default to both)
     * @param domainDeeplinks Filter to only Bitlinks that contain deeplinks configured with a custom domain (optional, default to both)
     * @param campaignGuid Filter to return only links for the given campaign GUID, can be provided (optional)
     * @param channelGuid Filter to return only links for the given channel GUID, can be provided, overrides all other parameters (optional)
     * @param customBitlink  (optional, default to both)
     * @param tags filter by given tags (optional)
     * @param launchpadIds filter by launchpad id (optional)
     * @param encodingLogin Filter by the login of the authenticated user that created the Bitlink (optional)
     * @return ApiResponse<Bitlinks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBitlinksByGroupWithHttpInfo(groupGuid: kotlin.String, size: kotlin.Int?, page: kotlin.Int?, keyword: kotlin.String?, query: kotlin.String?, createdBefore: kotlin.Int?, createdAfter: kotlin.Int?, modifiedAfter: kotlin.Int?, archived: Archived_getBitlinksByGroup?, deeplinks: Deeplinks_getBitlinksByGroup?, domainDeeplinks: DomainDeeplinks_getBitlinksByGroup?, campaignGuid: kotlin.String?, channelGuid: kotlin.String?, customBitlink: CustomBitlink_getBitlinksByGroup?, tags: kotlin.collections.List<kotlin.String>?, launchpadIds: kotlin.collections.List<kotlin.String>?, encodingLogin: kotlin.collections.List<kotlin.String>?): ApiResponse<Bitlinks?> {
        val localVariableConfig = getBitlinksByGroupRequestConfig(groupGuid = groupGuid, size = size, page = page, keyword = keyword, query = query, createdBefore = createdBefore, createdAfter = createdAfter, modifiedAfter = modifiedAfter, archived = archived, deeplinks = deeplinks, domainDeeplinks = domainDeeplinks, campaignGuid = campaignGuid, channelGuid = channelGuid, customBitlink = customBitlink, tags = tags, launchpadIds = launchpadIds, encodingLogin = encodingLogin)

        return request<Unit, Bitlinks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBitlinksByGroup
     *
     * @param groupGuid A GUID for a Bitly group
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param page Integer specifying the numbered result at which to start (optional, default to 1)
     * @param keyword Custom keyword to filter on history entries (optional)
     * @param query the value that you would like to search (optional)
     * @param createdBefore Timestamp as an integer unix epoch (optional)
     * @param createdAfter Timestamp as an integer unix epoch (optional)
     * @param modifiedAfter Timestamp as an integer unix epoch (optional)
     * @param archived Whether or not to include archived bitlinks (optional, default to off)
     * @param deeplinks Filter to only Bitlinks that contain deeplinks (optional, default to both)
     * @param domainDeeplinks Filter to only Bitlinks that contain deeplinks configured with a custom domain (optional, default to both)
     * @param campaignGuid Filter to return only links for the given campaign GUID, can be provided (optional)
     * @param channelGuid Filter to return only links for the given channel GUID, can be provided, overrides all other parameters (optional)
     * @param customBitlink  (optional, default to both)
     * @param tags filter by given tags (optional)
     * @param launchpadIds filter by launchpad id (optional)
     * @param encodingLogin Filter by the login of the authenticated user that created the Bitlink (optional)
     * @return RequestConfig
     */
    fun getBitlinksByGroupRequestConfig(groupGuid: kotlin.String, size: kotlin.Int?, page: kotlin.Int?, keyword: kotlin.String?, query: kotlin.String?, createdBefore: kotlin.Int?, createdAfter: kotlin.Int?, modifiedAfter: kotlin.Int?, archived: Archived_getBitlinksByGroup?, deeplinks: Deeplinks_getBitlinksByGroup?, domainDeeplinks: DomainDeeplinks_getBitlinksByGroup?, campaignGuid: kotlin.String?, channelGuid: kotlin.String?, customBitlink: CustomBitlink_getBitlinksByGroup?, tags: kotlin.collections.List<kotlin.String>?, launchpadIds: kotlin.collections.List<kotlin.String>?, encodingLogin: kotlin.collections.List<kotlin.String>?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (keyword != null) {
                    put("keyword", listOf(keyword.toString()))
                }
                if (query != null) {
                    put("query", listOf(query.toString()))
                }
                if (createdBefore != null) {
                    put("created_before", listOf(createdBefore.toString()))
                }
                if (createdAfter != null) {
                    put("created_after", listOf(createdAfter.toString()))
                }
                if (modifiedAfter != null) {
                    put("modified_after", listOf(modifiedAfter.toString()))
                }
                if (archived != null) {
                    put("archived", listOf(archived.toString()))
                }
                if (deeplinks != null) {
                    put("deeplinks", listOf(deeplinks.toString()))
                }
                if (domainDeeplinks != null) {
                    put("domain_deeplinks", listOf(domainDeeplinks.toString()))
                }
                if (campaignGuid != null) {
                    put("campaign_guid", listOf(campaignGuid.toString()))
                }
                if (channelGuid != null) {
                    put("channel_guid", listOf(channelGuid.toString()))
                }
                if (customBitlink != null) {
                    put("custom_bitlink", listOf(customBitlink.toString()))
                }
                if (tags != null) {
                    put("tags", toMultiValue(tags.toList(), "multi"))
                }
                if (launchpadIds != null) {
                    put("launchpad_ids", toMultiValue(launchpadIds.toList(), "multi"))
                }
                if (encodingLogin != null) {
                    put("encoding_login", toMultiValue(encodingLogin.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/groups/{group_guid}/bitlinks".replace("{" + "group_guid" + "}", encodeURIComponent(groupGuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Clicks for a Bitlink
     * Returns the click counts for the specified link in an array based on a date.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return Clicks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getClicksForBitlink(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, unitReference: kotlin.String? = null): Clicks {
        val localVarResponse = getClicksForBitlinkWithHttpInfo(bitlink = bitlink, unit = unit, units = units, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Clicks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Clicks for a Bitlink
     * Returns the click counts for the specified link in an array based on a date.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<Clicks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getClicksForBitlinkWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, unitReference: kotlin.String?): ApiResponse<Clicks?> {
        val localVariableConfig = getClicksForBitlinkRequestConfig(bitlink = bitlink, unit = unit, units = units, unitReference = unitReference)

        return request<Unit, Clicks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClicksForBitlink
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getClicksForBitlinkRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/clicks".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get a Clicks Summary for a Bitlink
     * Returns the click counts for the specified link rolled up into a single field.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ClicksSummary
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getClicksSummaryForBitlink(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, unitReference: kotlin.String? = null): ClicksSummary {
        val localVarResponse = getClicksSummaryForBitlinkWithHttpInfo(bitlink = bitlink, unit = unit, units = units, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClicksSummary
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a Clicks Summary for a Bitlink
     * Returns the click counts for the specified link rolled up into a single field.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<ClicksSummary?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getClicksSummaryForBitlinkWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, unitReference: kotlin.String?): ApiResponse<ClicksSummary?> {
        val localVariableConfig = getClicksSummaryForBitlinkRequestConfig(bitlink = bitlink, unit = unit, units = units, unitReference = unitReference)

        return request<Unit, ClicksSummary>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getClicksSummaryForBitlink
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getClicksSummaryForBitlinkRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/clicks/summary".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by City
     * Returns the city origins of click traffic for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return CityMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByCities(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): CityMetrics {
        val localVarResponse = getMetricsForBitlinkByCitiesWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CityMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by City
     * Returns the city origins of click traffic for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<CityMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByCitiesWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<CityMetrics?> {
        val localVariableConfig = getMetricsForBitlinkByCitiesRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, CityMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByCities
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByCitiesRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/cities".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by Country
     * Returns the country origins of click traffic for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ClickMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByCountries(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): ClickMetrics {
        val localVarResponse = getMetricsForBitlinkByCountriesWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClickMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by Country
     * Returns the country origins of click traffic for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<ClickMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByCountriesWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<ClickMetrics?> {
        val localVariableConfig = getMetricsForBitlinkByCountriesRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, ClickMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByCountries
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByCountriesRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/countries".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by Device Type
     * Returns the device types generating click traffic to the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return DeviceMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByDevices(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): DeviceMetrics {
        val localVarResponse = getMetricsForBitlinkByDevicesWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeviceMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by Device Type
     * Returns the device types generating click traffic to the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<DeviceMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByDevicesWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<DeviceMetrics?> {
        val localVariableConfig = getMetricsForBitlinkByDevicesRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, DeviceMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByDevices
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByDevicesRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/devices".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by Referrers
     * Returns referrer click counts for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ClickMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByReferrers(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): ClickMetrics {
        val localVarResponse = getMetricsForBitlinkByReferrersWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClickMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by Referrers
     * Returns referrer click counts for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<ClickMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByReferrersWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<ClickMetrics?> {
        val localVariableConfig = getMetricsForBitlinkByReferrersRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, ClickMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByReferrers
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByReferrersRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/referrers".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by Referrers by Domain
     * Returns click metrics grouped by referrers for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ReferrersByDomains
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByReferrersByDomains(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): ReferrersByDomains {
        val localVarResponse = getMetricsForBitlinkByReferrersByDomainsWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReferrersByDomains
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by Referrers by Domain
     * Returns click metrics grouped by referrers for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<ReferrersByDomains?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByReferrersByDomainsWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<ReferrersByDomains?> {
        val localVariableConfig = getMetricsForBitlinkByReferrersByDomainsRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, ReferrersByDomains>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByReferrersByDomains
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByReferrersByDomainsRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/referrers_by_domains".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Metrics for a Bitlink by Referring Domains
     * Returns the referring domain click counts for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ClickMetrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMetricsForBitlinkByReferringDomains(bitlink: kotlin.String, unit: TimeUnit = TimeUnit.day, units: kotlin.Int = -1, size: kotlin.Int? = 50, unitReference: kotlin.String? = null): ClickMetrics {
        val localVarResponse = getMetricsForBitlinkByReferringDomainsWithHttpInfo(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ClickMetrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Metrics for a Bitlink by Referring Domains
     * Returns the referring domain click counts for the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return ApiResponse<ClickMetrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMetricsForBitlinkByReferringDomainsWithHttpInfo(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): ApiResponse<ClickMetrics?> {
        val localVariableConfig = getMetricsForBitlinkByReferringDomainsRequestConfig(bitlink = bitlink, unit = unit, units = units, size = size, unitReference = unitReference)

        return request<Unit, ClickMetrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMetricsForBitlinkByReferringDomains
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param unit A unit of time (default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (default to -1)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @return RequestConfig
     */
    fun getMetricsForBitlinkByReferringDomainsRequestConfig(bitlink: kotlin.String, unit: TimeUnit, units: kotlin.Int, size: kotlin.Int?, unitReference: kotlin.String?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("unit", listOf(unit.toString()))
                put("units", listOf(units.toString()))
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/bitlinks/{bitlink}/referring_domains".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
    enum class Sort_getSortedBitlinks(val value: kotlin.String) {
        @Json(name = "clicks") clicks("clicks")
    }

    /**
     * Retrieve Sorted Bitlinks for Group
     * Returns a list of Bitlinks sorted by group.
     * @param groupGuid A GUID for a Bitly group
     * @param sort The type of sorting that you would like to do
     * @param unit A unit of time (optional, default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (optional, default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @return SortedLinks
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSortedBitlinks(groupGuid: kotlin.String, sort: Sort_getSortedBitlinks, unit: TimeUnit? = TimeUnit.day, units: kotlin.Int? = -1, unitReference: kotlin.String? = null, size: kotlin.Int? = 50): SortedLinks {
        val localVarResponse = getSortedBitlinksWithHttpInfo(groupGuid = groupGuid, sort = sort, unit = unit, units = units, unitReference = unitReference, size = size)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SortedLinks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Retrieve Sorted Bitlinks for Group
     * Returns a list of Bitlinks sorted by group.
     * @param groupGuid A GUID for a Bitly group
     * @param sort The type of sorting that you would like to do
     * @param unit A unit of time (optional, default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (optional, default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @return ApiResponse<SortedLinks?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSortedBitlinksWithHttpInfo(groupGuid: kotlin.String, sort: Sort_getSortedBitlinks, unit: TimeUnit?, units: kotlin.Int?, unitReference: kotlin.String?, size: kotlin.Int?): ApiResponse<SortedLinks?> {
        val localVariableConfig = getSortedBitlinksRequestConfig(groupGuid = groupGuid, sort = sort, unit = unit, units = units, unitReference = unitReference, size = size)

        return request<Unit, SortedLinks>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSortedBitlinks
     *
     * @param groupGuid A GUID for a Bitly group
     * @param sort The type of sorting that you would like to do
     * @param unit A unit of time (optional, default to day)
     * @param units An integer representing the time units to query data for. pass -1 to return all units of time. (optional, default to -1)
     * @param unitReference An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time. Timestamp values should be url encoded (i.e. replace &#39;+&#39; with &#39;%2B&#39; and &#39;:&#39; with &#39;%3A&#39;; 2022-02-02T15:53:02+0000 becomes 2022-02-02T15%3A53%3A02%2B0000) (optional)
     * @param size The quantity of items to be be returned (optional, default to 50)
     * @return RequestConfig
     */
    fun getSortedBitlinksRequestConfig(groupGuid: kotlin.String, sort: Sort_getSortedBitlinks, unit: TimeUnit?, units: kotlin.Int?, unitReference: kotlin.String?, size: kotlin.Int?): RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (unit != null) {
                    put("unit", listOf(unit.toString()))
                }
                if (units != null) {
                    put("units", listOf(units.toString()))
                }
                if (unitReference != null) {
                    put("unit_reference", listOf(unitReference.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/groups/{group_guid}/bitlinks/{sort}".replace("{" + "group_guid" + "}", encodeURIComponent(groupGuid.toString())).replace("{" + "sort" + "}", encodeURIComponent(sort.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a Bitlink
     * Updates fields in the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param bitlinkBody
     * @return BitlinkBody
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBitlink(bitlink: kotlin.String, bitlinkBody: BitlinkBody): BitlinkBody {
        val localVarResponse = updateBitlinkWithHttpInfo(bitlink = bitlink, bitlinkBody = bitlinkBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BitlinkBody
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a Bitlink
     * Updates fields in the specified link.
     * @param bitlink A Bitlink made of the domain and hash
     * @param bitlinkBody
     * @return ApiResponse<BitlinkBody?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBitlinkWithHttpInfo(bitlink: kotlin.String, bitlinkBody: BitlinkBody): ApiResponse<BitlinkBody?> {
        val localVariableConfig = updateBitlinkRequestConfig(bitlink = bitlink, bitlinkBody = bitlinkBody)

        return request<BitlinkBody, BitlinkBody>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBitlink
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param bitlinkBody
     * @return RequestConfig
     */
    fun updateBitlinkRequestConfig(bitlink: kotlin.String, bitlinkBody: BitlinkBody): RequestConfig<BitlinkBody> {
        val localVariableBody = bitlinkBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/bitlinks/{bitlink}".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a QR Code
     * Updates an existing QR Code
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return FullQRCode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBitlinkQRCode(bitlink: kotlin.String, qrCustomizations: QRCustomizations): FullQRCode {
        val localVarResponse = updateBitlinkQRCodeWithHttpInfo(bitlink = bitlink, qrCustomizations = qrCustomizations)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FullQRCode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a QR Code
     * Updates an existing QR Code
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return ApiResponse<FullQRCode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBitlinkQRCodeWithHttpInfo(bitlink: kotlin.String, qrCustomizations: QRCustomizations): ApiResponse<FullQRCode?> {
        val localVariableConfig = updateBitlinkQRCodeRequestConfig(bitlink = bitlink, qrCustomizations = qrCustomizations)

        return request<QRCustomizations, FullQRCode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBitlinkQRCode
     *
     * @param bitlink A Bitlink made of the domain and hash
     * @param qrCustomizations
     * @return RequestConfig
     */
    fun updateBitlinkQRCodeRequestConfig(bitlink: kotlin.String, qrCustomizations: QRCustomizations): RequestConfig<QRCustomizations> {
        val localVariableBody = qrCustomizations
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/bitlinks/{bitlink}/qr".replace("{" + "bitlink" + "}", encodeURIComponent(bitlink.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Bulk update bitlinks
     * Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a list of bitlink ids that were updated.
     * @param groupGuid A GUID for a Bitly group
     * @param bulkUpdateRequest
     * @return BulkUpdate
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBitlinksByGroup(groupGuid: kotlin.String, bulkUpdateRequest: BulkUpdateRequest): BulkUpdate {
        val localVarResponse = updateBitlinksByGroupWithHttpInfo(groupGuid = groupGuid, bulkUpdateRequest = bulkUpdateRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BulkUpdate
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bulk update bitlinks
     * Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a list of bitlink ids that were updated.
     * @param groupGuid A GUID for a Bitly group
     * @param bulkUpdateRequest
     * @return ApiResponse<BulkUpdate?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBitlinksByGroupWithHttpInfo(groupGuid: kotlin.String, bulkUpdateRequest: BulkUpdateRequest): ApiResponse<BulkUpdate?> {
        val localVariableConfig = updateBitlinksByGroupRequestConfig(groupGuid = groupGuid, bulkUpdateRequest = bulkUpdateRequest)

        return request<BulkUpdateRequest, BulkUpdate>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBitlinksByGroup
     *
     * @param groupGuid A GUID for a Bitly group
     * @param bulkUpdateRequest
     * @return RequestConfig
     */
    fun updateBitlinksByGroupRequestConfig(groupGuid: kotlin.String, bulkUpdateRequest: BulkUpdateRequest): RequestConfig<BulkUpdateRequest> {
        val localVariableBody = bulkUpdateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/groups/{group_guid}/bitlinks".replace("{" + "group_guid" + "}", encodeURIComponent(groupGuid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
